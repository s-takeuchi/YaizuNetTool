<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<link rel="stylesheet" href="./style.css" type="text/css">
</HEAD>

<style type="text/css">
<!--
.spc { margin-left: 2em; margin-right: 0em; }
-->
</style>

<BODY>
<div id="container">
<H1>6. 処理要素について</H1>

<H2 ID="6.1">6.1 処理要素概要</H2>
StkFwのワークスペースでは，1つまたは複数のデータフローを定義することができます。<BR>
データフローは，1つまたは複数のスレッドから構成されます。
スレッドは，さらにデータの受信，加工，送信等を行う処理（処理要素）の組み合わせとして定義されます。<BR>
各処理要素間には処理間関連線を，各スレッド間にはスレッド間関連線を設定することでができます
（処理間関連線は白色の実線で，スレッド間関連線は緑色の点線で表現されます）。<BR>
StkFwは，スレッドコントローラにより，個々のスレッドを独立して実行制御することができます。<P>
<CENTER><IMG SRC="dataflow.jpg"></CENTER><P>


処理要素は以下の種類に大別されます。<P>
<TABLE BORDER="1">
<TR><TD>Initiator</TD><TD>スレッドの開始を示す処理要素です。スレッドコントローラからInitiatorの処理要素を選択して
実行／停止を制御することができます。</TD></TR>
<TR><TD>Terminator</TD><TD>スレッドの終端を示す処理要素です。Terminatorの処理要素がスレッド間関連線で別スレッドのInitiator
の処理要素と連結している場合は，本処理要素の次のInitiatorの処理要素に処理が移ります。Terminatorの処理要素とリンクしているInitiatorの
処理要素が存在しない場合，Terminatorの処理要素が属するデータフローの先頭となるInitiatorの処理要素に処理が戻ります。</TD></TR>
<TR><TD>Stopper</TD><TD>スレッドの終端を示す処理要素です。Terminatorの処理要素と異なり，Stopperの処理要素はスレッド間関連線で
別スレッドのInitiatorの処理要素と連結できません。このため処理はStopperから先に進むことはありません。
また，本処理要素の次の処理として，データフローの先頭にあるInitiatorに処理は戻りません。</TD></TR>
<TR><TD>Check point</TD><TD>条件判定用の処理要素です。
Check pointの処理要素に処理が移ると，ある与えられた条件を満たすまで次の処理要素に処理が移りません。</TD></TR>
<TR><TD>Action</TD><TD>与えられた特定の処理を実行するための処理要素です。処理実行後，無条件で次の処理要素に処理が移ります。</TD></TR>
</TABLE>
<P>
ワークスペース，スレッドに関する制約は以下のとおりです。<P>
<TABLE BORDER="1">
<TR><TD>1スレッド内に定義できる処理要素の最大数</TD><TD>99</TD></TR>
<TR><TD>1ワークスペース内に定義できる処理要素の最大数</TD><TD>499</TD></TR>
<tr><td>1ワークスペース内に定義できるTCP/UDP receiver/senderの処理要素の最大数</td><td>256</td></tr>
</TABLE><BR>
※データフロー内の各処理要素間の関連線（処理間関連線およびスレッド間関連線）を設定する場合，関連線がループ（関連線が循環）
する構成を設定することはできません。
関連線がループする構成を作成した場合，スレッド実行時に適切に動作しないおそれがあります。<P>


<H2 ID="6.2">6.2 TCP receiver [Initiator]</H2>
(1) 処理要素の名称： TCP receiver [Initiator]<BR>
(2) 処理要素の種別： Initiator<BR>
(3) 説明：<BR>
<div class=spc>
種別がTCP receiverの処理要素は受信要素と呼びます。<br>
受信要素は以下のいずれかの方法でデータを受信します。受信プロトコルにはTCPを使用します。<BR>
<UL>
<LI>指定したIPアドレスとポートからデータを受信する
<LI>指定した送信要素の接続先からデータを受信する
<LI>指定した受信要素からデータを受信する
</UL>
前述の"指定したIPアドレスとポートからデータを受信する"で，同じIPアドレスとポートを指定した複数の受信要素を設定することはできません。
"指定したIPアドレスとポートからデータを受信する"を選択した場合，1つのポートが同時にACCEPTできるコネクションの数は1つのみです。
ただし，"指定したIPアドレスとポートからデータを受信する"を指定した受信要素とともに，"指定した受信要素からデータを受信する"を指定
した受信要素を作成することにより，同一のポートで複数のクライアントからのコネクションを保つことができます。<br>
待ちうけ可能コネクションの数（LISTENにおけるBacklog数）は固定で5となっています。
<p>
TCPによるデータの送受信において，送信データと受信データは必ずしも一致するわけではありません。
例えば，TCP senderが大きなサイズのデータを送信した場合，それがいくつかの小さなサイズのデータ
に分割されTCP receiverに到達することがあります。また，TCP senderが送信したいくつかのデータが連結
されTCP receiverに到達することもあります。これはTCPの一般的な振る舞いであるため，StkFwで制御する
ことはできません。したがって，データの読み込みを完了し次の処理要素に処理を進めるタイミングが
どこであるかをTCP receiverに条件として設定する必要があります。<br>
次の処理要素に処理が移る条件として，以下の条件を指定することができます。<br>
<ul>

<li>無条件で次の処理要素に移る</li>
データ受信後次の処理要素に処理を進めます。
送信側との通信が確立したあとに，送信側のソケットのクローズを検知した場合も次の処理要素に処理を進めます。

<li>送信側ソケットがクローズされたときだけ次の処理要素に移る</li>
送信側のソケットのクローズを検知したときだけ次の処理要素に移ります。

<li>最終アクセス以降にタイムアウトを検知した</li>
データを受信したあと，次のデータを一定時間以上受信しない場合(タイムアウトを検知した場合)，次の処理要素に処理を進めます。
[データ未受信でも次の処理要素に遷移する]を有効にすると，送信側との通信が確立したあと，何もデータを
受信しなくても，次の処理要素に処理を進めます。
送信側との通信が確立したあとに，送信側のソケットのクローズを検知した場合も次の処理要素に処理を進めます。

<li>指定したデータを受信した</li>
指定したデータを受信した場合，次の処理要素に処理を進めます。
[データ未受信でも次の処理要素に遷移する]を有効にすると，送信側との通信が確立したあと，何もデータを
受信しなくても，次の処理要素に処理を進めます。
データを受信したあと，次のデータを一定時間以上受信しない場合(タイムアウトを検知した場合)，次の処理要素に処理を進めます。
送信側との通信が確立したあとに，送信側のソケットのクローズを検知した場合も次の処理要素に処理を進めます。

<li>受信データサイズが指定した値に達した</li>
指定したサイズに受信したデータが達した場合，次の処理要素に処理を進めます。
データを受信したあと，次のデータを一定時間以上受信しない場合(タイムアウトを検知した場合)，次の処理要素に処理を進めます。
[データ未受信でも次の処理要素に遷移する]を有効にすると，送信側との通信が確立したあと，何もデータを
受信しなくても，次の処理要素に処理を進めます。
送信側との通信が確立したあとに，送信側のソケットのクローズを検知した場合も次の処理要素に処理を進めます。

<li>HTTPヘッダのContent-Lengthまたは"Transfer-Encoding: chunked"にしたがう</li>
HTTPヘッダにContent-Lengthが指定されている場合，Content-Lengthで指定したバイト数のデータを受信後，次の処理要素に処理を進めます。<br/>
HTTPヘッダに"Transfer-Encoding: chunked"が指定されている場合，Chunkをすべて受信後，次の処理要素に処理を進めます。<br/>
上記の何れでもない場合，HTTPヘッダを受信後，次の処理要素に処理を進めます。<br/>
データを受信したあと，次のデータを一定時間以上受信しない場合(タイムアウトを検知した場合)，次の処理要素に処理を進めます。
[データ未受信でも次の処理要素に遷移する]を有効にすると，送信側との通信が確立したあと，何もデータを
受信しなくても，次の処理要素に処理を進めます。
送信側との通信が確立したあとに，送信側のソケットのクローズを検知した場合も次の処理要素に処理を進めます。

</ul><br>

<p>タイムアウト(msec)に0を指定した場合，タイムアウトは検知されません。</p>

上記のTCPの振る舞いに関して次の注意事項があります。<br>
下図に示すデータフローが定義されており，TCP senderおよびTCP receiverはソケットをクローズしません。
TCP senderの入力データがいくつかのデータに分割されTCP receiverに送信されたるとすると，
TCP receiverの受信バッファにデータが溜まり続け，最終的にTCP senderが送信待ちで永久に待機状態となります。
この問題を回避するためには，下図におけるスレッド間関連線を削除する必要があります。<br>
<img src="RecvNote.jpg"><br>
<p>

データ受信後に，ソケットをクローズするかどうかを指定することができます。
通常のクローズの場合，相手側のシャットダウンまたはクローズを待ち，ソケットのクローズを行います。
具体的には次のステップによりクローズします。<p>
shutdown(SD_SEND)を発行 → 対象のソケットに届いているすべてのデータをrecv()で受信 → shutdown(SD_BOTH)を発行 → closesocket()を発行<p>
このため，受信要素がソケットをクローズするためには，相手側が先にソケットをクローズしている必要があります。
ただし"強制的にクローズ"を指定した場合，データ受信後に無条件にclosesocket()を発行します。<p>

また，TCP receiverは，接続相手であるTCP senderのソケットのクローズを検知し，
TCP receiverの受信用ソケットをクローズします（データ受信後にソケットをクローズする設定を行っていない場合もクローズします）。

</div><BR>
(4) 入力： なし<BR>
(5) 出力： 受信したデータ<BR>
(6) 処理完了条件： データを受信する<BR>
<P>



<H2 ID="6.3">6.3 UDP receiver [Initiator]</H2>
(1) 処理要素の名称： UDP receiver [Initiator]<BR>
(2) 処理要素の種別： Initiator<BR>
(3) 説明：<BR>
<div class=spc>
この処理要素は以下のいずれかの方法でデータを受信します。受信プロトコルにはUDPを使用します。<BR>
<UL>
<LI>指定したIPアドレスとポートからデータを受信します。
<LI>指定した送信要素の接続先からデータを受信します。
</UL>
指定した送信要素の接続先からデータを受信する場合，データを受信したあと受信用ソケットをクローズするかどうかを
選択することができます。<br>
種別がUDP receiverの処理要素は受信要素と呼ばれます。
同じIPアドレスとポートを使用した複数の受信要素を設定することはできません。<BR>
</div><BR>
(4) 入力： なし<BR>
(5) 出力： 受信したデータ<BR>
(6) 処理完了条件： データを受信する<BR>
<P>



<H2 ID="6.4">6.4 Load data [Initiator]</H2>
(1) 処理要素の名称： Load data [Initiator]<BR>
(2) 処理要素の種別： Initiator<BR>
(3) 説明：<BR>
<div class=spc>
この処理要素は指定したコミュニケーション用変数からデータを読込みます。
データの読込み方法には以下の２種類があります。<BR>
<UL>
<LI>単一のコミュニケーション用変数からデータを読込みます。
<LI>複数のコミュニケーション用変数から連続的にデータを読込みます。
</UL>
複数のコミュニケーション用変数から連続的にデータを読込む場合，読み込み対象のコミュニケーション用変数の変数名は
以下のように定義されている必要があります。<P>
コミュニケーション用変数名：  XXXXXnnnnn<P>
XXXXXは変数名のプレフィックスで0～26文字の文字列となります。nnnnnは5桁の数値となります。数値が5桁に満たない場合，
nnnnnのは先頭から0を埋めた値として扱われます。
nnnnnで示される数値は，この処理要素に処理が移る度に1加算されます。<BR>
コミュニケーション用変数からデータ読込むと処理間関連線で接続した次の処理要素に処理が進みます。<BR>
</div><BR>
(4) 入力： なし<BR>
(5) 出力： コミュニケーション用変数から読込んだデータ<BR>
(6) 処理完了条件： コミュニケーション用変数からデータ読込む<BR>
<P>



<H2 ID="6.5">6.5 Empty box [Initiator]</H2>
(1) 処理要素の名称： Empty box [Initiator]<BR>
(2) 処理要素の種別： Initiator<BR>
(3) 説明：<BR>
<div class=spc>
この処理要素はInitiatorであり，スレッドを開始しますが，それ以外には何も行いません。
無条件で処理間関連線で接続した次の処理要素に処理が進みます。
</div><BR>
(4) 入力： なし<BR>
(5) 出力： なし<BR>
(6) 処理完了条件： なし<BR>
<P>



<H2 ID="6.6">6.6 TCP sender [Terminator/Stopper]</H2>
(1) 処理要素の名称： TCP sender [Terminator/Stopper]<BR>
(2) 処理要素の種別： Terminator または Stopper<BR>
(3) 説明：<BR>
<div class=spc>
種別がTCP senderの処理要素は送信要素と呼びます。<br>
送信要素は以下のいずれかの方法でデータを送信します。送信プロトコルにはTCPを使用します。<BR>
<UL>
<LI>指定したIPアドレスとポートにデータを送信します。
<LI>指定した受信要素の接続先にデータを送信します。
</UL>
処理要素の種別がTerminatorの場合，データ送信後にスレッド間関連線で接続した次の処理要素(Initiator)に処理が進むか，
処理要素が属するデータフローの先頭に処理が戻ります。
送信先の受信要素の受信バッファが足りない場合，TCP senderは受信バッファが空くまで待機します。<br>
同じIPアドレスとポートを送信先とする複数の送信要素を設定する場合，1つの受信要素が同時にACCEPTできる
コネクションの数は1つのみとなるため注意が必要です。<p>

データ送信後に，ソケットをクローズするかどうかを指定することができます。
通常のクローズの場合，相手側のシャットダウンまたはクローズを待ち，ソケットのクローズを行います。
具体的には次のステップによりクローズします。<p>
shutdown(SD_SEND)を発行 → 対象のソケットに届いているすべてのデータをrecv()で受信 → shutdown(SD_BOTH)を発行 → closesocket()を発行<p>
このため，送信要素がソケットをクローズするためには，相手側が先にソケットをクローズしている必要があります。
ただし"強制的にクローズ"を指定した場合，データ送信後に無条件にclosesocket()を発行します。<br>
</div><BR>
(4) 入力： 送信用データ<BR>
(5) 出力： なし<BR>
(6) 処理完了条件： データを送信する<BR>
<P>



<H2 ID="6.7">6.7 UDP sender [Terminator/Stopper]</H2>
(1) 処理要素の名称： UDP sender [Terminator/Stopper]<BR>
(2) 処理要素の種別： Terminator または Stopper<BR>
(3) 説明：<BR>
<div class=spc>
この処理要素は以下のいずれかの方法でデータを送信します。送信プロトコルにはUDPを使用します。<BR>
<UL>
<LI>指定したIPアドレスとポートにデータを送信します。
<LI>指定した受信要素の接続先にデータを送信します。
</UL>
IPアドレスに255.255.255.255を指定した場合，ブロードキャストでデータを送信することができます。
マルチキャストでのデータ送信はサポートしていません。<br>
処理要素の種別がTerminatorの場合，データ送信後にスレッド間関連線で接続した次の処理要素(Initiator)に処理が進むか，
処理要素が属するデータフローの先頭に処理が戻ります。
種別がUDP senderの処理要素は送信要素と言われます。<br>
指定したIPアドレスとポートにデータを送信する場合，データ送信後にソケットをクローズするかどうかを指定することができます。
</div><BR>
(4) 入力： 送信用データ<BR>
(5) 出力： なし<BR>
(6) 処理完了条件： データを送信する<BR>
<P>



<H2 ID="6.8">6.8 Store data [Terminator/Stopper]</H2>
(1) 処理要素の名称： Store sender [Terminator/Stopper]<BR>
(2) 処理要素の種別： Terminator または Stopper<BR>
(3) 説明：<BR>
<div class=spc>
この処理要素は指定したコミュニケーション用変数にデータを書込みます。
データの書込み方法には以下の２種類があります。<BR>
<UL>
<LI>単一のコミュニケーション用変数にデータを書込みます。
<LI>複数のコミュニケーション用変数に連続的にデータを書込みます。
</UL>
複数のコミュニケーション用変数に連続的にデータを書込む場合，書込み対象のコミュニケーション用変数の変数名は
以下のように定義されている必要があります。<P>
コミュニケーション用変数名：  XXXXXnnnnn<P>
XXXXXは変数名のプレフィックスで0～26文字の文字列となります。nnnnnは5桁の数値となります。数値が5桁に満たない場合，
nnnnnのは先頭から0を埋めた値として扱われます。
nnnnnで示される数値は，この処理要素に処理が移る度に1加算されます。<BR>
処理要素の種別がTerminatorの場合，処理完了後にスレッド間関連線で接続した次の処理要素(Initiator)に処理が進むか，
処理要素が属するデータフローの先頭に処理が戻ります。<BR>
</div><BR>
(4) 入力： コミュニケーション用変数に書込むデータ<BR>
(5) 出力： なし<BR>
(6) 処理完了条件： なし<BR>
<P>



<H2 ID="6.9">6.9 Empty box [Terminator/Stopper]</H2>
(1) 処理要素の名称： Empty box [Terminator/Stopperr]<BR>
(2) 処理要素の種別： Terminator または Stopper<BR>
(3) 説明：<BR>
<div class=spc>
何も行いません。
処理要素の種別がTerminatorの場合，無条件でスレッド間関連線でで接続した次の処理要素(Initiator)に処理が進むか，
処理要素が属するデータフローの先頭に処理が戻ります。
</div><BR>
(4) 入力： なし<BR>
(5) 出力： なし<BR>
(6) 処理完了条件： なし<BR>
<P>



<H2 ID="6.10">6.10 Check flag</H2>
(1) 処理要素の名称： Check flag<BR>
(2) 処理要素の種別： Check point<BR>
(3) 説明：<BR>
<div class=spc>
フラグ用変数の値が与えられた条件を満たすかチェックします。<BR>
指定したフラグ用変数の値が与えられた条件(TrueまたはFalse)と一致する場合，入力データをそのまま出力し，
処理間関連線で接続した次の処理要素に処理が進みます。
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 入力データをそのまま出力する<BR>
(6) 処理完了条件： フラグ用変数の値が条件を満たす<BR>
<P>



<H2 ID="6.11">6.11 Check data</H2>
(1) 処理要素の名称： Check data<BR>
(2) 処理要素の種別： Check point<BR>
(3) 説明：<BR>
<div class=spc>
入力したデータが与えられた条件を満たすかチェックします。<BR>
チェックは，コミュニケーション用変数の値との比較によって行われ，次に示す何れかのチェック種別を選択することができます。<BR>
<UL>
<LI>入力データは指定した変数の値から開始する。
<LI>入力データは指定した変数の値から開始しない。
<LI>入力データは指定した変数の値で終了する。
<LI>入力データは指定した変数の値で終了しない。
<LI>入力データは指定した変数の値を含む。
<LI>入力データは指定した変数の値を含まない。
<LI>入力データは指定した変数の値と完全一致する。
<LI>入力データは指定した変数の値と完全一致しない。
</UL>
チェックした結果が真となる場合，入力データをそのまま出力し，処理間関連線で接続した次の処理要素に処理が進みます。
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 入力データをそのまま出力する<BR>
(6) 処理完了条件： 入力したデータが与えられた条件を満たす<BR>
<P>



<H2 ID="6.12">6.12 Timer</H2>
(1) 処理要素の名称： Timer<BR>
(2) 処理要素の種別： Check point<BR>
(3) 説明：<BR>
<div class=spc>
一定時間待つために時間をチェックします。<BR>
時間をチェックする方法には以下の２つがあます。<BR>
<UL>
<LI>指定した日時・時刻が過ぎたか
<LI>この処理要素に処理が移ったあと指定した待ち時間（間隔）が過ぎたか
</UL>
チェックした結果が真となる場合，入力データをそのまま出力し，処理間関連線で接続した次の処理要素に処理が進みます。
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 入力データをそのまま出力する<BR>
(6) 処理完了条件： 指定した条件（日時・時刻／経過時間）を満たす<BR>
<P>



<H2 ID="6.13">6.13 Change flag</H2>
(1) 処理要素の名称： Change flag<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
指定したフラグ用変数の値を変更します。<BR>
その後無条件で処理間関連線でで接続した次の処理要素に処理が進みます。
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 入力データをそのまま出力する<BR>
(6) 処理完了条件： なし<BR>
<P>



<H2 ID="6.14">6.14 Change data</H2>
(1) 処理要素の名称： Change data<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
入力したデータを加工し出力します。<BR>
出力後，処理間関連線で接続した次の処理要素に処理が進みます。
データの加工種別には以下に示すものがあります。
<UL>
<LI>入力データの開始バイトに指定したコミュニケーション用変数の値を挿入します。
<LI>入力データの終了バイトに指定したコミュニケーション用変数の値を挿入します。
<LI>入力データからデータを検索し，指定したコミュニケーション用変数の値に置換します。
<LI>入力データから特定の領域を抽出します。
<LI>入力データを捨て空のデータを再設定します。
<LI>入力データを捨て指定したコミュニケーション用変数の値に置換します。
</UL>
加工した結果，出力データが9,999,999バイトを超えた場合，入力データと同じデータが出力されます。
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 入力データを加工したデータを出力する<BR>
(6) 処理完了条件： なし<BR>
<P>



<H2 ID="6.15">6.15 Aggregation/Distribution</H2>
(1) 処理要素の名称： Aggregation/Distribution<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
処理を分離／統合します。<BR>
この処理要素には複数の処理間関連線を設定することができます。
複数の入力側関連線のうちの1つにデータが入力されると，複数の出力側関連線の全てに入力されたデータが出力されます。<BR>
同一スレッドで分離された処理を統合する場合，同時に複数のデータを入力することができません。
<IMG SRC="ThreadImg1.jpg"><BR>
例えば上図ではAとBが同時にデータを出力する場合，先に本処理要素に入力されたデータのみ処理され，後に入力されたデータ
は無視されます。<BR>
<P>
ただし下図のようにスレッドが異なる場合，AおよびBの出力データは本処理要素で適切に処理されます。<BR>
<IMG SRC="ThreadImg2.jpg">
<p>
複数のスレッドが一部の処理要素を共有して同時に動作する構成を考えます。<br>
あるスレッドがTerminatorに到達した場合，Initiatorに戻るのはそのスレッドの処理のみで，
他のスレッドに影響を及ぼしません。<br>
例えば，下図に示すように，A～Cのスレッドがあり，A2で30秒待機，B2で35秒待機，C2で40秒待機したとします。
最初にスレッドAがTerminatorに到達しますが，Initiatorに戻るのはスレッドAのみで，スレッドB, Cは残分の時間
を待機後にTerminatorに到達します。
<img src="threads.jpg">
<br>
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 入力データをそのまま出力する<BR>
(6) 処理完了条件： なし<BR>
<P>



<H2 ID="6.16">6.16 Close port</H2>
(1) 処理要素の名称： Close port<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
指定した送信要素または受信要素のソケットをクローズします。<p>
通常のクローズの場合，相手側のシャットダウンまたはクローズを待ち，ソケットのクローズを行います。
具体的には次のステップによりクローズします。<p>
shutdown(SD_SEND)を発行 → 対象のソケットに届いているすべてのデータをrecv()で受信 → shutdown(SD_BOTH)を発行 → closesocket()を発行<p>
このため，本処理要素がソケットをクローズするためには，相手側が先にソケットをクローズしている必要があります。
ただし"強制的にクローズ"を指定した場合，無条件にclosesocket()を発行します。<br>
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 入力データをそのまま出力する<BR>
(6) 処理完了条件： なし<BR>
<P>



<H2 ID="6.17">6.17 Mapper</H2>
(1) 処理要素の名称： Mapper<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
入力データと出力データをマッピングします。<BR>
入力データと出力データをマッピングするために以下の情報を与える必要があります。
<UL>
<LI>入力データを判別するコミュニケーション用変数の名称のプレフィックス (XXXXX)
<LI>出力データとなるコミュニケーション用変数の名称のプレフィックス (YYYYY)
<LI>変数名のプレフィックスのあとにつづく数値
</UL>
入力データがXXXXXnnnnn(XXXXXは入力データの変数名のプレフィックス，nnnnnは変数名のあとにつづく5桁の数値)と一致する場合，
対応するコミュニケーション用変数YYYYYnnnnn(YYYYYは入力データの変数名のプレフィックス，nnnnnは変数名のあとにつづく5桁の数値)
を出力します。<br>
「各変数へのマッピングは一度だけ使用される」がチェックされている場合，ある入力に対するマッピングは一度だけ使用されます。
例えば以下のコミュニケーション用変数が定義されており，<p>
Input00000="tokyo", Output00000="shinagawa"<br>
Input00001="kanagawa", Output00001="yokohama"<br>
Input00002="aichi", Output00002="nagoya"<br>
Input00003="tokyo", Output00003="shinjyuku"<p>
"Input"と"Output"を対応付けるMapperがある場合，最初に"tokyo"が入力された場合"shinagawa"を返しますが，
次に"tokyo"が入力された場合"shinjyuku"を返します。「各変数へのマッピングは一度だけ使用される」がチェックされていな場合，
"tokyo"が入力ならば常に"shinagawa"が返されます。

</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： マップした結果を出力する<BR>
(6) 処理完了条件： マッピング可能なコミュニケーション用変数が存在する<BR>
<P>



<H2 ID="6.18">6.18 Write file</H2>
(1) 処理要素の名称： Write file<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
入力データを指定したファイルに書き込みます。<br>
ファイルの書き込み種別として以下を指定することができます。
<ul>
<li>既存のファイルを上書きする。<br>
<div class=spc>
指定したパスに同名のファイルが存在する場合，ファイルの中身は入力データに置き換えられます。
指定したパスにファイルが存在しない場合，StkFwは新規にファイルを作成します。
</div>
<li>既存のファイルの先頭にデータを挿入する。
<div class=spc>
指定したパスに同名のファイルが存在する場合，ファイルの先頭に入力データを挿入します。
指定したパスにファイルが存在しない場合，StkFwは新規にファイルを作成します。
</div>
<li>既存のファイルの最後にデータを連結する。
<div class=spc>
指定したパスに同名のファイルが存在する場合，ファイルの最後に入力データを連結します。
指定したパスにファイルが存在しない場合，StkFwは新規にファイルを作成します。
</div>
</ul>
次の事象が発生した場合，ファイルアクセスエラーとなり，当該処理要素で処理を停止します。<br>
<ul>
<li>ファイルへの書き込み対象データのサイズが9,999,999バイトを超えた。
<li>ファイルへの書き込みが失敗した。
</ul>
ファイルアクセスエラーが発生した際，書き込み対象ファイルの内容は不定となります。
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 指定したファイルに書き込んだデータを出力する<BR>
(6) 処理完了条件： ファイルへの書き込みが終了した。<BR>
<P>



<H2 ID="6.19">6.19 Read file</H2>
(1) 処理要素の名称： Read file<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
入力データと指定したファイルから読み込んだデータを加工して出力します。<br>
加工種別として以下を指定することができます。
<ul>
<li>ファイルから読み込んだデータを出力する
<div class=spc>
指定したファイルからデータを読み込み出力します。
</div>
<li>入力データの開始バイトに読み込んだデータを挿入する
<div class=spc>
指定したファイルから読み込んだデータを入力データの開始バイトに挿入し出力します。
</div>
<li>入力データの終了バイトに読み込んだデータを連結する
<div class=spc>
指定したファイルから読み込んだデータを入力データの終了バイトに連結し出力します。
</div>
</ul>
次の事象が発生した場合，ファイルアクセスエラーとなり，当該処理要素で処理を停止します。<br>
<ul>
<li>ファイルのサイズが9,999,999バイトを超えた。
<li>指定したパスにファイルが見つからない。
<li>ファイルの読み込みが失敗した。
</ul>
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 指定したファイルから読み込んだデータと入力データを加工して出力する<BR>
(6) 処理完了条件： ファイルからの読み込みが終了した。<BR>
<P>



<H2 ID="6.20">6.20 Execute program</H2>
(1) 処理要素の名称： Execute program<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
外部のプログラムを実行します。<br>
外部プログラム実行後、本処理要素の入力データを外部プログラムのSTDINとして渡します。また，
実行した外部プログラムのSTDOUTへの出力が本処理要素の出力となります。
外部プログラムのSTDOUTへの出力が9,999,999バイトを超えた場合，次の処理要素に処理を
進めることができません。
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： 外部プログラムのSTDOUT出力データがそのまま本処理要素の出力となる<BR>
(6) 処理完了条件： 外部プログラムが開始／終了した。<BR>
<P>



<H2 ID="6.21">6.21 HTTP header</H2>
(1) 処理要素の名称： HTTP header<BR>
(2) 処理要素の種別： Action<BR>
(3) 説明：<BR>
<div class=spc>
下記の操作を行うことができます。<br/>
<ul>
<li>入力データからHTTPヘッダを削除する</li>
<li>出力データにHTTPヘッダを挿入する</li>
</ul>
入力データからHTTPヘッダを削除する操作を行う場合，HTTPヘッダは，適切なHTTPメソッドで開始し，改行コードのみの行までの区間として判別されます。<br>
出力データにHTTPヘッダを挿入する操作を行う場合，任意の文字列を指定することができます。<br/>
</div><BR>
(4) 入力： 処理関連線で接続した前の処理要素の出力<BR>
(5) 出力： HTTPヘッダを削除または追加したデータを出力する<BR>
(6) 処理完了条件： HTTPヘッダに関する加工が完了した。<BR>
<P>



</BODY>
